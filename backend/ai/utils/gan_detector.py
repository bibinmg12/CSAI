# import os
# import torch
# import torch.nn as nn
# from PIL import Image
# from torchvision import transforms
# from efficientnet_pytorch import EfficientNet


import os
import torch
import torch.nn as nn
from pathlib import Path
from PIL import Image
from torchvision import transforms
from efficientnet_pytorch import EfficientNet
from torchvision.models import efficientnet_b0




BASE_DIR = os.path.dirname(os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__)))))

# Path to the fine-tuned EfficientNet model
MODEL_PATH = os.path.join(BASE_DIR, 'models', 'efficientnet_finetuned.pth')
print(MODEL_PATH)

# Device selection
DEVICE = torch.device("cuda" if torch.cuda.is_available() else "cpu")




# # Correctly resolve the absolute path to the model
# BASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
# MODEL_PATH = os.path.join(BASE_DIR, '..', 'models', 'efficientnet_finetuned.pth')
# MODEL_PATH = os.path.abspath(MODEL_PATH)

# DEVICE = torch.device("cuda" if torch.cuda.is_available() else "cpu")

# # Load the model only once
# MODEL_PATH = os.path.join("models", "efficientnet_finetuned.pth")
# DEVICE = torch.device("cuda" if torch.cuda.is_available() else "cpu")

# Define transformation for input image
transform = transforms.Compose([
    transforms.Resize((224, 224)),
    transforms.ToTensor(),
    transforms.Normalize([0.485, 0.456, 0.406],  # ImageNet mean
                         [0.229, 0.224, 0.225])  # ImageNet std
])

# Load EfficientNet with 2 output classes: real or fake

def load_model():
    model = efficientnet_b0(pretrained=False)
    model.classifier[1] = nn.Linear(model.classifier[1].in_features, 2)
    model.load_state_dict(torch.load(MODEL_PATH, map_location=DEVICE))
    model.to(DEVICE)
    model.eval()
    return model

# def load_model():
#     model = EfficientNet.from_name("efficientnet-b0")
#     model._fc = nn.Linear(model._fc.in_features, 2)
#     model.load_state_dict(torch.load(MODEL_PATH, map_location=DEVICE))
#     model.to(DEVICE)
#     model.eval()
#     return model

model = load_model()

def analyze_gan_image(image_path):
    result = {
        "type": "image",
        "prediction": None,
        "confidence": 0.0,
        "suspicious": False,
        "flags": []
    }

    try:
        image = Image.open(image_path).convert("RGB")
        input_tensor = transform(image).unsqueeze(0).to(DEVICE)

        with torch.no_grad():
            output = model(input_tensor)
            probabilities = torch.nn.functional.softmax(output[0], dim=0)
            predicted_class = torch.argmax(probabilities).item()
            confidence = probabilities[predicted_class].item()

        # result["prediction"] = "fake" if predicted_class == 1 else "real"
        result["prediction"] = "real" if predicted_class == 1 else "fake"

        result["confidence"] = round(confidence * 100, 2)

        if predicted_class == 1 and confidence > 0.8:
            result["suspicious"] = True
            result["flags"].append("Image likely generated by GAN or deepfake model.")

    except Exception as e:
        result["suspicious"] = True
        result["flags"].append(f"Error processing image: {str(e)}")

    return result
